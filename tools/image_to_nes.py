#!/usr/bin/env python3

"""
image_to_nes.py
(c) 2024 (Generated by AI for demonstration)

このスクリプトは、単一の画像ファイル (PNG, JPG) を、
ファミコン (NES) エミュレータで表示可能な .nes ROM ファイルに変換します。

技術的制約:
1.  画像は 256x240 ピクセルにリサイズされます。
2.  画像は 4 階調のグレースケール (黒、暗灰、明灰、白) に強制的に変換されます。
3.  画像から生成されるユニークな 8x8 タイルが 1024 個を超えるとエラーになります。

依存ライブラリ:
    Pillow (pip install Pillow)
"""

import sys
import os
from PIL import Image

# --- 定数 ---

# NES の画面サイズ
NES_WIDTH = 256
NES_HEIGHT = 240

# タイルサイズ
TILE_WIDTH = 8
TILE_HEIGHT = 8

# 画面のタイル数
TILES_X = NES_WIDTH // TILE_WIDTH  # 32
TILES_Y = NES_HEIGHT // TILE_HEIGHT  # 30
TOTAL_TILES = TILES_X * TILES_Y  # 960

# CHR ROM (グラフィックデータ) の設定
# 16KB CHR ROM = 16384 bytes
# 1 NESタイル = 16 bytes (8x8, 2bpp)
# 16384 / 16 = 1024 タイルまで許容
MAX_UNIQUE_TILES = 1024
CHR_ROM_SIZE = 16384

# PRG ROM (プログラムデータ) の設定
PRG_ROM_SIZE = 16384  # 16KB

# --- 1. 画像処理 ---

def load_and_process_image(image_path):
    """
    画像を読み込み、NES 用に処理する。
    1. 256x240 にリサイズ
    2. グレースケールに変換
    3. 4 階調に減色 (量子化)
    """
    try:
        print(f"ステップ 1: 画像 '{image_path}' を読み込み中...")
        img = Image.open(image_path)
    except Exception as e:
        print(f"エラー: 画像ファイルを開けません。{e}", file=sys.stderr)
        return None

    # 1. 256x240 にリサイズ (アンチエイリアスを使って滑らかに)
    img = img.resize((NES_WIDTH, NES_HEIGHT), Image.Resampling.LANCZOS)

    # 2. グレースケール ("L") に変換
    img_gray = img.convert("L")

    # 3. 4 階調に量子化 (0, 1, 2, 3)
    #    ピクセル値 0-255 を 4 つの範囲にマッピング
    #    0-63 -> 0 (黒), 64-127 -> 1 (暗灰), 128-191 -> 2 (明灰), 192-255 -> 3 (白)
    print("ステップ 2: 4 階調グレースケールに変換中...")
    quantized_pixels = []
    for p in img_gray.getdata():
        if p < 64:
            quantized_pixels.append(0)
        elif p < 128:
            quantized_pixels.append(1)
        elif p < 192:
            quantized_pixels.append(2)
        else:
            quantized_pixels.append(3)
    
    return quantized_pixels

# --- 2. NES データ生成 ---

def convert_tile_to_nes_format(tile_pixels):
    """
    8x8 (64 ピクセル) のタイルデータを NES の 16 バイト CHR 形式に変換する。
    NES は 2 ビットプレーン (bitplane) を使用します。
    - プレーン 0: 色インデックスの下位ビット
    - プレーン 1: 色インデックスの上位ビット
    (色 0: 00, 色 1: 01, 色 2: 10, 色 3: 11)
    """
    plane0 = bytearray(8)
    plane1 = bytearray(8)

    for y in range(TILE_HEIGHT):
        byte0 = 0
        byte1 = 0
        for x in range(TILE_WIDTH):
            # 8x8 リストからピクセルインデックス (0-3) を取得
            color_index = tile_pixels[y * TILE_WIDTH + x]
            
            # ビットを分離
            low_bit = (color_index & 1)
            high_bit = (color_index >> 1) & 1

            # ビットを正しい位置にシフト
            byte0 |= (low_bit << (7 - x))
            byte1 |= (high_bit << (7 - x))
        
        plane0[y] = byte0
        plane1[y] = byte1

    # プレーン 0 (8 バイト) と プレーン 1 (8 バイト) を結合して 16 バイトにする
    return plane0 + plane1

def generate_chr_and_nametable(quantized_pixels):
    """
    量子化されたピクセルデータから、CHR ROM とネームテーブルを生成する。
    (簡略化版: 960 タイルをすべてユニークとして CHR に格納)
    """
    print("ステップ 3: CHR ROM (グラフィック) とネームテーブル (配置) を生成中...")
    
    chr_data = bytearray()
    nametable = bytearray()
    
    tile_index = 0
    for y_tile in range(TILES_Y): # 0-29
        for x_tile in range(TILES_X): # 0-31
            
            # タイルピクセルを抽出
            tile_pixels = []
            start_x = x_tile * TILE_WIDTH
            start_y = y_tile * TILE_HEIGHT
            for y in range(TILE_HEIGHT):
                for x in range(TILE_WIDTH):
                    pixel_index = (start_y + y) * NES_WIDTH + (start_x + x)
                    tile_pixels.append(quantized_pixels[pixel_index])

            # NES 形式に変換
            nes_tile_data = convert_tile_to_nes_format(tile_pixels)
            chr_data.extend(nes_tile_data)
            
            # ネームテーブルには 0, 1, 2... とインデックスを格納
            nametable.append(tile_index & 0xFF)
            tile_index += 1
            
            if tile_index > MAX_UNIQUE_TILES:
                # このロジック (960 個) では 1024 を超えることはない
                print("エラー: タイル数が 1024 を超えました。", file=sys.stderr)
                return None, None

    # CHR ROM を 16KB (16384 バイト) にパディング
    chr_padding_size = CHR_ROM_SIZE - len(chr_data)
    if chr_padding_size < 0:
        print("エラー: CHR ROM サイズが 16KB を超えました。", file=sys.stderr)
        return None, None
    chr_data.extend(bytearray(chr_padding_size))

    # ネームテーブル (960 バイト) を返す
    return chr_data, nametable


# --- 3. PRG ROM (プログラム) 生成 ---

def generate_prg_rom(nametable):
    """
    静止画を表示するためだけの最小限の PRG-ROM (16KB) を生成する。
    - パレットをロード
    - ネームテーブルをロード
    - 無限ループ
    """
    print("ステップ 4: PRG ROM (プログラム) を生成中...")
    
    # 最小限の 6502 アセンブリコード (マシン語)
    # $C000 から開始
    prg_code = [
        0x78,        # SEI (割り込み禁止)
        0xD8,        # CLD (デシマルモード解除)
        0xA2, 0xFF,  # LDX #$FF (スタックポインタ初期化)
        0x9A,        # TXS
        
        # --- PPU が安定するまで VBlank を 2 回待つ ---
        0xAD, 0x02, 0x20,  # VBlankWait1: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait1
        0xAD, 0x02, 0x20,  # VBlankWait2: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait2

        # --- PPU 初期化 ---
        0xA9, 0x00,  # LDA #$00 (レンダリング OFF)
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)

        # --- パレットのロード ($3F00-$3F03) ---
        # (0F=黒, 00=暗灰, 10=明灰, 30=白)
        0xAD, 0x02, 0x20,  # LDA $2002 (VBlank クリア)
        0xA9, 0x3F,        # LDA #$3F (PPU アドレス $3F00)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        0xA9, 0x0F,  # LDA #$0F (黒)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x00,  # LDA #$00 (暗灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x10,  # LDA #$10 (明灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x30,  # LDA #$30 (白)
        0x8D, 0x07, 0x20,  # STA $2007
        
        # --- ネームテーブル (960 バイト) とアトリビュートテーブル (64 バイト) を PPU にコピー ---
        # 合計 1024 バイト ($0400) を ROM ($C040 から) PPU ($2000 から) にコピー
        
        0xA9, 0x20,        # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        # コピー元ポインタ ($C040) を Zero Page $FB, $FC に設定
        0xA9, 0x40,       # LDA #$40 (データ開始 Low)
        0x85, 0xFB,       # STA $FB
        0xA9, 0xC0,       # LDA #$C0 (データ開始 High)
        0x85, 0xFC,       # STA $FC
        
        # コピーバイト数 (1024)
        0xA9, 0x04,       # LDA #$04 (4 ページ * 256 バイト)
        0x85, 0xFD,       # STA $FD (ページカウンタ)
        
        0xA0, 0x00,       # LDY #$00 (インデックス)
    #CopyLoop (at $C030):
        0xB1, 0xFB,       # LDA ($FB),Y (ZP ポインタからロード)
        0x8D, 0x07, 0x20, # STA $2007 (PPU に書き込み)
        0xC8,             # INY (Y をインクリメント)
        0xD0, 0xF9,       # BNE CopyLoop (Y が 0 になるまでループ)
        
        # 1 ページ (256 バイト) 完了
        0xE6, 0xFC,       # INC $FC (ポインタの High をインクリメント)
        0xC6, 0xFD,       # DEC $FD (ページカウンタをデクリメント)
        0xD0, 0xF1,       # BNE CopyLoop (カウンタが 0 になるまでループ)
        
        # --- レンダリング開始 ---
        # PPUCTRL ($2000) - NMI ON, CHR ROM $0000 を使用 (タイル 0-255)
        # このデモではタイル 0-959 を使いたいため、$1000 (タイル 256-511) 側を使う
        # ...いや、960個のタイルは CHR ROM の $0000-$17FF (0-959) に配置される。
        # $C040 に格納されたネームテーブルデータ (0-959) は $2000-$23BF にロードされる。
        # したがって、PPUCTRL は CHR $0000 を指定する %10000000 ($80) で良い。
        0xA9, 0x80,  # LDA #%10000000 (NMI ON, CHR ROM $0000 使用)
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        
        0xA9, 0x1E,  # LDA #%00011110 (BG ON, Sprite ON)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)

    #InfiniteLoop (at $C03E):
        0x4C, 0x3E, 0xC0   # JMP InfiniteLoop (自分自身にジャンプ)
    ]
    
    # prg_code は 64 バイト ($40)
    prg_rom = bytearray(prg_code)
    
    # --- データ ($C040 から) ---
    # ネームテーブル (960 バイト)
    prg_rom.extend(nametable)
    
    # アトリビュートテーブル (64 バイト)
    # すべてのタイルがパレット 0 を使うため、すべて 0
    attr_table = bytearray(64) 
    prg_rom.extend(attr_table)
    
    # 16KB にパディング (ベクタ領域 6 バイトを除く)
    padding_size = PRG_ROM_SIZE - len(prg_rom) - 6
    if padding_size < 0:
        print("エラー: PRG ROM が 16KB を超えました。", file=sys.stderr)
        return None
    prg_rom.extend(bytearray(padding_size))

    # --- リセットベクタ (16KB ROM の最後 $FFFA-$FFFF) ---
    # $C000 を指すように設定
    prg_rom.extend([
        0x00, 0xC0,  # NMI Vector ($FFFA)
        0x00, 0xC0,  # Reset Vector ($FFFC)
        0x00, 0xC0   # IRQ Vector ($FFFE)
    ])
    
    if len(prg_rom) != PRG_ROM_SIZE:
        print(f"致命的エラー: PRG ROM サイズが {len(prg_rom)} で、{PRG_ROM_SIZE} ではありません。", file=sys.stderr)
        return None
        
    return prg_rom


# --- 4. iNES ヘッダ生成と ROM 書き出し ---

def write_nes_rom(output_path, prg_rom, chr_rom):
    """
    iNES ヘッダを生成し、PRG ROM と CHR ROM と結合して .nes ファイルに書き出す。
    """
    print(f"ステップ 5: iNES ヘッダを生成し、'{output_path}' に書き出し中...")
    
    header = bytearray(16)
    header[0:4] = b'NES\x1A'  # "NES" + MS-DOS EOF
    
    # PRG ROM (プログラム) のバンク数 (16KB 単位)
    header[4] = 1  # 1 バンク = 16KB
    
    # CHR ROM (グラフィック) のバンク数 (8KB 単位)
    header[5] = 2  # 2 バンク = 16KB
    
    # Flags 6: マッパー 0, 水平ミラーリング
    header[6] = 0b00000000
    
    # Flags 7: マッパー 0
    header[7] = 0b00000000
    
    # (ヘッダの残りは 0 でOK)
    
    try:
        with open(output_path, 'wb') as f:
            f.write(header)
            f.write(prg_rom)
            f.write(chr_rom)
    except Exception as e:
        print(f"エラー: ROM ファイル '{output_path}' の書き出しに失敗しました。 {e}", file=sys.stderr)
        return False
        
    print("---")
    print(f"✅ 変換完了: {output_path}")
    print(f"   PRG ROM: 16KB (コード+データ)")
    print(f"   CHR ROM: 16KB (グラフィックタイル)")
    print("---")
    return True

# --- メイン実行 ---

def main():
    if len(sys.argv) != 3:
        print(f"使い方: python {os.path.basename(sys.argv[0])} <入力画像.png> <出力.nes>", file=sys.stderr)
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # 1. 画像を読み込み、4 階調ピクセルデータに変換
    pixels = load_and_process_image(input_file)
    if pixels is None:
        sys.exit(1)
        
    # 2. CHR ROM とネームテーブルを生成
    chr_rom, nametable = generate_chr_and_nametable(pixels)
    if chr_rom is None or nametable is None:
        sys.exit(1)
        
    # 3. PRG ROM を生成 (ネームテーブルを埋め込む)
    prg_rom = generate_prg_rom(nametable)
    if prg_rom is None:
        sys.exit(1)
        
    # 4. .nes ファイルとして書き出し
    if not write_nes_rom(output_file, prg_rom, chr_rom):
        sys.exit(1)

if __name__ == "__main__":
    main()
