#!/usr/bin/env python3

"""
image_to_nes.py (V3 - バグ修正版)
(c) 2024 (Generated by AI for demonstration)

このスクリプトは、単一の画像ファイル (PNG, JPG) を、
ファミコン (NES) エミュレータで表示可能な .nes ROM ファイルに変換します。

技術的制約:
1.  画像は 256x240 ピクセルにリサイズされます。
2.  画像は 4 階調のグレースケール (黒、暗灰、明灰、白) に強制的に変換されます。
3.  画像から生成されるユニークな 8x8 タイルが 256 個を超えるとエラーになります。

依存ライブラリ:
    Pillow (pip install Pillow)
"""

import sys
import os
from PIL import Image

# --- 定数 ---
NES_WIDTH = 256
NES_HEIGHT = 240
TILE_WIDTH = 8
TILE_HEIGHT = 8
TILES_X = NES_WIDTH // TILE_WIDTH  # 32
TILES_Y = NES_HEIGHT // TILE_HEIGHT  # 30
TOTAL_TILES = TILES_X * TILES_Y  # 960

MAX_UNIQUE_TILES = 256
CHR_ROM_SIZE = 8192    # 8KB (256 tiles * 16 bytes/tile * 2 planes)
PRG_ROM_SIZE = 16384   # 16KB

# --- 1. 画像処理 (変更なし) ---

def load_and_process_image(image_path):
    """
    画像を読み込み、NES 用に処理する。
    1. 256x240 にリサイズ
    2. グレースケールに変換
    3. 4 階調に減色 (量子化)
    """
    try:
        print(f"ステップ 1: 画像 '{image_path}' を読み込み中...")
        img = Image.open(image_path)
    except Exception as e:
        print(f"エラー: 画像ファイルを開けません。{e}", file=sys.stderr)
        return None

    img = img.resize((NES_WIDTH, NES_HEIGHT), Image.Resampling.LANCZOS)
    img_gray = img.convert("L")

    print("ステップ 2: 4 階調グレースケールに変換中...")
    quantized_pixels = []
    for p in img_gray.getdata():
        if p < 64:
            quantized_pixels.append(0)
        elif p < 128:
            quantized_pixels.append(1)
        elif p < 192:
            quantized_pixels.append(2)
        else:
            quantized_pixels.append(3)
    
    return quantized_pixels

# --- 2. NES データ生成 (変更なし) ---

def convert_tile_to_nes_format(tile_pixels):
    """
    8x8 (64 ピクセル) のタイルデータを NES の 16 バイト CHR 形式に変換する。
    """
    plane0 = bytearray(8)
    plane1 = bytearray(8)

    for y in range(TILE_HEIGHT):
        byte0 = 0
        byte1 = 0
        for x in range(TILE_WIDTH):
            color_index = tile_pixels[y * TILE_WIDTH + x]
            low_bit = (color_index & 1)
            high_bit = (color_index >> 1) & 1
            byte0 |= (low_bit << (7 - x))
            byte1 |= (high_bit << (7 - x))
        
        plane0[y] = byte0
        plane1[y] = byte1
    
    return plane0 + plane1

# --- 3. CHR ROM とネームテーブル生成 (変更なし) ---

def generate_chr_and_nametable(quantized_pixels):
    """
    量子化されたピクセルデータから、CHR ROM とネームテーブルを生成する。
    (256 個のユニークタイルを見つけるロジック)
    """
    print(f"ステップ 3: CHR ROM (グラフィック) とネームテーブル (配置) を生成中...")
    
    unique_tiles = {}       # 見つかったユニークなタイルを保存 (key=tile_data, value=index)
    chr_data = bytearray()  # CHR ROM データ
    nametable = bytearray(TOTAL_TILES) # ネームテーブルデータ
    tile_index_counter = 0

    for y_tile in range(TILES_Y):  # 0-29
        for x_tile in range(TILES_X):  # 0-31
            
            tile_pixels = []
            start_x = x_tile * TILE_WIDTH
            start_y = y_tile * TILE_HEIGHT
            for y in range(TILE_HEIGHT):
                for x in range(TILE_WIDTH):
                    pixel_index = (start_y + y) * NES_WIDTH + (start_x + x)
                    tile_pixels.append(quantized_pixels[pixel_index])
            
            tile_tuple = tuple(tile_pixels)

            if tile_tuple not in unique_tiles:
                if tile_index_counter >= MAX_UNIQUE_TILES:
                    print(f"--------------------------------------------------", file=sys.stderr)
                    print(f"エラー: 画像が複雑すぎます。", file=sys.stderr)
                    print(f"ユニークな 8x8 タイルが {MAX_UNIQUE_TILES} 個の上限を超えました。", file=sys.stderr)
                    print(f"より単純な画像 (ドット絵など) を試してください。", file=sys.stderr)
                    print(f"--------------------------------------------------", file=sys.stderr)
                    return None, None
                
                unique_tiles[tile_tuple] = tile_index_counter
                nes_tile_data = convert_tile_to_nes_format(tile_pixels)
                chr_data.extend(nes_tile_data)
                current_tile_index = tile_index_counter
                tile_index_counter += 1
            else:
                current_tile_index = unique_tiles[tile_tuple]
            
            nametable[y_tile * TILES_X + x_tile] = current_tile_index
    
    print(f"情報: 発見されたユニークタイル数: {tile_index_counter} / {MAX_UNIQUE_TILES}")

    chr_padding_size = CHR_ROM_SIZE - len(chr_data)
    if chr_padding_size < 0:
        print("エラー: CHR ROM サイズが 8KB を超えました。", file=sys.stderr) 
        return None, None
    chr_data.extend(bytearray(chr_padding_size))

    return chr_data, nametable


# --- 4. PRG ROM (プログラム) 生成 (★★★ バグ修正版 ★★★) ---

def generate_prg_rom(nametable):
    """
    静止画を表示するためだけの最小限の PRG-ROM (16KB) を生成する。
    (V3: NMI 無効化、VRAM クリア追加、ジャンプバグ修正)
    """
    print("ステップ 4: PRG ROM (プログラム) を生成中...")
    
    prg_code = [
        0x78,        # SEI (割り込み禁止)
        0xD8,        # CLD (デシマルモード解除)
        0xA2, 0xFF,  # LDX #$FF (スタックポインタ初期化)
        0x9A,        # TXS
        
        # --- PPU が安定するまで VBlank を 2 回待つ ---
        0xAD, 0x02, 0x20,  # VBlankWait1: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait1
        0xAD, 0x02, 0x20,  # VBlankWait2: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait2

        # --- PPU 初期化 (レンダリング OFF) ---
        0xA9, 0x00,  # LDA #$00
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL - NMI OFF)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK - RENDER OFF)

        # --- VRAM ($2000-$23FF) を $00 でクリア (ゴミデータ掃除) ---
        0xAD, 0x02, 0x20,  # VBlankWait3: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait3

        0xA9, 0x20,        # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        0xA9, 0x00,        # LDA #$00 (クリアデータ)
        0xA2, 0x04,        # LDX #$04 (1024 バイト / 256 = 4 ページ)
    #ClearLoopPage ($C021):
        0xA0, 0x00,        # LDY #$00
    #ClearLoop ($C023):
        0x8D, 0x07, 0x20,  # STA $2007
        0xC8,              # INY
        0xD0, 0xFB,        # BNE ClearLoop
        0xCA,              # DEX
        0xD0, 0xF7,        # BNE ClearLoopPage
        
        # --- パレットのロード ($3F00-$3F03) ---
        0xAD, 0x02, 0x20,  # LDA $2002 (VBlank クリア)
        0xA9, 0x3F,        # LDA #$3F (PPU アドレス $3F00)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        0xA9, 0x0F,  # LDA #$0F (黒)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x00,  # LDA #$00 (暗灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x10,  # LDA #$10 (明灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x30,  # LDA #$30 (白)
        0x8D, 0x07, 0x20,  # STA $2007
        
        # --- ネームテーブル (960 バイト) とアトリビュートテーブル (64 バイト) を PPU にコピー ---
        0xA9, 0x20,        # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        # コピー元ポインタ ($C000 + data_offset) を Zero Page $FB, $FC に設定
        # (この時点でのコード長 0x4B)
        0xA9, 0x00,       # LDA #$?? (データ開始 Low) <- 後で上書き
        0x85, 0xFB,       # STA $FB
        0xA9, 0x00,       # LDA #$?? (データ開始 High) <- 後で上書き
        0x85, 0xFC,       # STA $FC
        
        0xA9, 0x04,       # LDA #$04 (4 ページ * 256 バイト)
        0x85, 0xFD,       # STA $FD (ページカウンタ)
        
        0xA0, 0x00,       # LDY #$00 (インデックス)
    #CopyLoop ($C053):
        0xB1, 0xFB,       # LDA ($FB),Y
        0x8D, 0x07, 0x20, # STA $2007
        0xC8,             # INY
        0xD0, 0xF9,       # BNE CopyLoop (Y が 0 になるまで)
        
        0xE6, 0xFC,       # INC $FC (ポインタの High をインクリメント)
        0xC6, 0xFD,       # DEC $FD (ページカウンタをデクリメント)
        
        # BNE CopyLoop ($C053) へのジャンプ
        # $C05B + 2 + offset = $C053
        # $C05D + offset = $C053
        # offset = $C053 - $C05D = -$0A = 0xF6
        0xD0, 0xF6,       # BNE CopyLoop
        
        # --- レンダリング開始 ---
        
        # ★★★ NMI を無効のまま BG $0000 を使用 (暴走バグ修正)
        0xA9, 0x00,  # LDA #%00000000 (NMI OFF, BG $0000)
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        
        0xA9, 0x0E,  # LDA #%00001110 (BG ON, Sprite OFF)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)

    #InfiniteLoop ($C063):
        0x4C, 0x00, 0x00   # JMP InfiniteLoop <- 後で上書き
    ]
    
    # --- PRG ROM の動的アドレス修正 ---
    
    # 無限ループ (JMP) のアドレスを修正
    loop_addr = 0xC000 + len(prg_code) - 3 # $C063
    prg_code[-3] = loop_addr & 0xFF        # $63
    prg_code[-2] = (loop_addr >> 8) & 0xFF # $C0
    
    # データ開始アドレス (ネームテーブル) を修正
    data_start_addr = 0xC000 + len(prg_code) # $C066
    prg_code[0x4B + 1] = data_start_addr & 0xFF        # $66 (LDA #$66)
    prg_code[0x4E + 1] = (data_start_addr >> 8) & 0xFF # $C0 (LDA #$C0)
    
    # ---
    
    prg_rom = bytearray(prg_code)
    
    # --- データ ($C066 から) ---
    prg_rom.extend(nametable)
    attr_table = bytearray(64) # アトリビュートテーブル (すべてパレット 0)
    prg_rom.extend(attr_table)
    
    # 16KB にパディング (ベクタ領域 6 バイトを除く)
    padding_size = PRG_ROM_SIZE - len(prg_rom) - 6
    if padding_size < 0:
        print("エラー: PRG ROM が 16KB を超えました。", file=sys.stderr)
        return None
    prg_rom.extend(bytearray(padding_size))

    # --- リセットベクタ (16KB ROM の最後 $FFFA-$FFFF) ---
    prg_rom.extend([
        0x00, 0xC0,  # NMI Vector ($FFFA) -> $C000 (使われない)
        0x00, 0xC0,  # Reset Vector ($FFFC) -> $C000 (ここから開始)
        0x00, 0xC0   # IRQ Vector ($FFFE) -> $C000 (使われない)
    ])
    
    if len(prg_rom) != PRG_ROM_SIZE:
        print(f"致命的エラー: PRG ROM サイズが {len(prg_rom)} で、{PRG_ROM_SIZE} ではありません。", file=sys.stderr)
        return None
        
    return prg_rom


# --- 5. iNES ヘッダ生成と ROM 書き出し (変更なし) ---

def write_nes_rom(output_path, prg_rom, chr_rom):
    """
    iNES ヘッダを生成し、PRG ROM と CHR ROM と結合して .nes ファイルに書き出す。
    """
    print(f"ステップ 5: iNES ヘッダを生成し、'{output_path}' に書き出し中...")
    
    header = bytearray(16)
    header[0:4] = b'NES\x1A'  # "NES" + MS-DOS EOF
    header[4] = 1  # PRG ROM (16KB) x 1
    header[5] = 1  # CHR ROM (8KB) x 1
    header[6] = 0b00000000 # マッパー 0, 水平ミラーリング
    header[7] = 0b00000000 # マッパー 0
    
    try:
        with open(output_path, 'wb') as f:
            f.write(header)
            f.write(prg_rom)
            f.write(chr_rom)
    except Exception as e:
        print(f"エラー: ROM ファイル '{output_path}' の書き出しに失敗しました。 {e}", file=sys.stderr)
        return False
        
    print("---")
    print(f"✅ 変換完了: {output_path}")
    print(f"   PRG ROM: 16KB (コード+データ)")
    print(f"   CHR ROM: 8KB (グラフィックタイル)")
    print("---")
    return True

# --- メイン実行 (変更なし) ---

def main():
    if len(sys.argv) != 3:
        print(f"使い方: python {os.path.basename(sys.argv[0])} <入力画像.png> <出力.nes>", file=sys.stderr)
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    pixels = load_and_process_image(input_file)
    if pixels is None:
        sys.exit(1)
        
    chr_rom, nametable = generate_chr_and_nametable(pixels)
    if chr_rom is None or nametable is None:
        sys.exit(1)
        
    prg_rom = generate_prg_rom(nametable)
    if prg_rom is None:
        sys.exit(1)
        
    if not write_nes_rom(output_file, prg_rom, chr_rom):
        sys.exit(1)

if __name__ == "__main__":
    main()
