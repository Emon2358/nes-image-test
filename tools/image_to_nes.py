#!/usr/bin/env python3

"""
image_to_nes.py (改善版)
(c) 2024 (Generated by AI for demonstration)

このスクリプトは、単一の画像ファイル (PNG, JPG) を、
ファミコン (NES) エミュレータで表示可能な .nes ROM ファイルに変換します。

技術的制約 (改善版):
1.  画像は 256x240 ピクセルにリサイズされます。
2.  画像は 4 階調のグレースケール (黒、暗灰、明灰、白) に強制的に変換されます。
3.  画像から生成されるユニークな 8x8 タイルが 256 個を超えるとエラーになります。
    (NES マッパー 0 の 8KB CHR ROM 制限のため)

依存ライブラリ:
    Pillow (pip install Pillow)
"""

import sys
import os
from PIL import Image

# --- 定数 ---

# NES の画面サイズ
NES_WIDTH = 256
NES_HEIGHT = 240

# タイルサイズ
TILE_WIDTH = 8
TILE_HEIGHT = 8

# 画面のタイル数
TILES_X = NES_WIDTH // TILE_WIDTH  # 32
TILES_Y = NES_HEIGHT // TILE_HEIGHT  # 30
TOTAL_TILES = TILES_X * TILES_Y  # 960

# CHR ROM (グラフィックデータ) の設定
# 8KB CHR ROM = 8192 bytes
# 1 NESタイル = 16 bytes (8x8, 2bpp)
# 8192 / 16 = 512 タイルまで許容
# ただし、マッパー 0 では BG タイルは 256 個までしか参照できない。
MAX_UNIQUE_TILES = 256  # ★制限を 256 に変更
CHR_ROM_SIZE = 8192       # ★8KB に変更

# PRG ROM (プログラムデータ) の設定
PRG_ROM_SIZE = 16384  # 16KB

# --- 1. 画像処理 (変更なし) ---

def load_and_process_image(image_path):
    """
    画像を読み込み、NES 用に処理する。
    1. 256x240 にリサイズ
    2. グレースケールに変換
    3. 4 階調に減色 (量子化)
    """
    try:
        print(f"ステップ 1: 画像 '{image_path}' を読み込み中...")
        img = Image.open(image_path)
    except Exception as e:
        print(f"エラー: 画像ファイルを開けません。{e}", file=sys.stderr)
        return None

    img = img.resize((NES_WIDTH, NES_HEIGHT), Image.Resampling.LANCZOS)
    img_gray = img.convert("L")

    print("ステップ 2: 4 階調グレースケールに変換中...")
    quantized_pixels = []
    for p in img_gray.getdata():
        if p < 64:
            quantized_pixels.append(0)
        elif p < 128:
            quantized_pixels.append(1)
        elif p < 192:
            quantized_pixels.append(2)
        else:
            quantized_pixels.append(3)
    
    return quantized_pixels

# --- 2. NES データ生成 (変更なし) ---

def convert_tile_to_nes_format(tile_pixels):
    """
    8x8 (64 ピクセル) のタイルデータを NES の 16 バイト CHR 形式に変換する。
    """
    plane0 = bytearray(8)
    plane1 = bytearray(8)

    for y in range(TILE_HEIGHT):
        byte0 = 0
        byte1 = 0
        for x in range(TILE_WIDTH):
            color_index = tile_pixels[y * TILE_WIDTH + x]
            low_bit = (color_index & 1)
            high_bit = (color_index >> 1) & 1
            byte0 |= (low_bit << (7 - x))
            byte1 |= (high_bit << (7 - x))
        
        plane0[y] = byte0
        plane1[y] = byte1
    
    return plane0 + plane1

# --- 3. CHR ROM とネームテーブル生成 (★ロジック変更) ---

def generate_chr_and_nametable(quantized_pixels):
    """
    量子化されたピクセルデータから、CHR ROM とネームテーブルを生成する。
    (改善版: 256 個のユニークタイルを見つけるロジック)
    """
    print(f"ステップ 3: CHR ROM (グラフィック) とネームテーブル (配置) を生成中...")
    
    unique_tiles = {}       # 見つかったユニークなタイルを保存 (key=tile_data, value=index)
    chr_data = bytearray()  # CHR ROM データ (16 バイト * N タイル)
    nametable = bytearray(TOTAL_TILES) # ネームテーブルデータ (960 バイト)
    tile_index_counter = 0

    for y_tile in range(TILES_Y):  # 0-29
        for x_tile in range(TILES_X):  # 0-31
            
            # 8x8 のタイルピクセルデータを画像全体から抽出
            tile_pixels = []
            start_x = x_tile * TILE_WIDTH
            start_y = y_tile * TILE_HEIGHT
            for y in range(TILE_HEIGHT):
                for x in range(TILE_WIDTH):
                    pixel_index = (start_y + y) * NES_WIDTH + (start_x + x)
                    tile_pixels.append(quantized_pixels[pixel_index])
            
            # このタイルがユニークかどうかをチェック
            # (高速化のため、list を不変の tuple に変換して dict のキーにする)
            tile_tuple = tuple(tile_pixels)

            if tile_tuple not in unique_tiles:
                # 新しいユニークなタイル
                if tile_index_counter >= MAX_UNIQUE_TILES:
                    print(f"--------------------------------------------------", file=sys.stderr)
                    print(f"エラー: 画像が複雑すぎます。", file=sys.stderr)
                    print(f"ユニークな 8x8 タイルが {MAX_UNIQUE_TILES} 個の上限を超えました。", file=sys.stderr)
                    print(f"より単純な画像 (ドット絵など) を試してください。", file=sys.stderr)
                    print(f"--------------------------------------------------", file=sys.stderr)
                    return None, None
                
                # 新しいインデックスを割り当て
                unique_tiles[tile_tuple] = tile_index_counter
                
                # NES 形式 (16 バイト) に変換して CHR ROM に追加
                nes_tile_data = convert_tile_to_nes_format(tile_pixels)
                chr_data.extend(nes_tile_data)
                
                current_tile_index = tile_index_counter
                tile_index_counter += 1
            else:
                # 既存のタイル
                current_tile_index = unique_tiles[tile_tuple]
            
            # ネームテーブルに、この位置 (y_tile, x_tile) にどのタイルインデックスを使うかを記録
            nametable[y_tile * TILES_X + x_tile] = current_tile_index
    
    print(f"情報: 発見されたユニークタイル数: {tile_index_counter} / {MAX_UNIQUE_TILES}")

    # CHR ROM を 8KB (8192 バイト) にパディング
    chr_padding_size = CHR_ROM_SIZE - len(chr_data)
    if chr_padding_size < 0:
        # このロジックでは MAX_UNIQUE_TILES 制御により 8KB を超えることはない
        print("エラー: CHR ROM サイズが 8KB を超えました。", file=sys.stderr) 
        return None, None
    chr_data.extend(bytearray(chr_padding_size))

    # ネームテーブル (960 バイト) を返す
    return chr_data, nametable


# --- 4. PRG ROM (プログラム) 生成 (★バグ修正) ---

def generate_prg_rom(nametable):
    """
    静止画を表示するためだけの最小限の PRG-ROM (16KB) を生成する。
    """
    print("ステップ 4: PRG ROM (プログラム) を生成中...")
    
    prg_code = [
        0x78,        # SEI
        0xD8,        # CLD
        0xA2, 0xFF,  # LDX #$FF
        0x9A,        # TXS
        
        # --- VBlank 待機 (x2) ---
        0xAD, 0x02, 0x20,  # VBlankWait1: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait1
        0xAD, 0x02, 0x20,  # VBlankWait2: LDA $2002
        0x10, 0xFB,        # BPL VBlankWait2

        # --- PPU 初期化 ---
        0xA9, 0x00,  # LDA #$00 (レンダリング OFF)
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)

        # --- パレットのロード ($3F00-$3F03) ---
        # (0F=黒, 00=暗灰, 10=明灰, 30=白)
        0xAD, 0x02, 0x20,  # LDA $2002
        0xA9, 0x3F,        # LDA #$3F (PPU アドレス $3F00)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        0xA9, 0x0F,  # LDA #$0F (黒)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x00,  # LDA #$00 (暗灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x10,  # LDA #$10 (明灰)
        0x8D, 0x07, 20,  # STA $2007
        0xA9, 0x30,  # LDA #$30 (白)
        0x8D, 0x07, 0x20,  # STA $2007
        
        # --- ネームテーブル (960 バイト) とアトリビュートテーブル (64 バイト) を PPU にコピー ---
        # 合計 1024 バイト ($0400) を ROM ($C040 から) PPU ($2000 から) にコピー
        
        0xA9, 0x20,        # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        # コピー元ポインタ ($C040) を Zero Page $FB, $FC に設定
        0xA9, 0x40,       # LDA #$40 (データ開始 Low)
        0x85, 0xFB,       # STA $FB
        0xA9, 0xC0,       # LDA #$C0 (データ開始 High)
        0x85, 0xFC,       # STA $FC
        
        # コピーバイト数 (1024)
        0xA9, 0x04,       # LDA #$04 (4 ページ * 256 バイト)
        0x85, 0xFD,       # STA $FD (ページカウンタ)
        
        0xA0, 0x00,       # LDY #$00 (インデックス)
    #CopyLoop (at $C030):
        0xB1, 0xFB,       # LDA ($FB),Y
        0x8D, 0x07, 0x20, # STA $2007
        0xC8,             # INY
        0xD0, 0xF9,       # BNE CopyLoop (Y が 0 になるまで)
        
        # 1 ページ (256 バイト) 完了
        0xE6, 0xFC,       # INC $FC (ポインタの High をインクリメント)
        0xC6, 0xFD,       # DEC $FD (ページカウンタをデクリメント)
        
        # ★★★ バグ修正 ★★★
        # 0xD0, 0xF1 (誤) -> 0xD0, 0xF4 (正)
        # $C030 (CopyLoop) にジャンプし直す
        0xD0, 0xF4,       # BNE CopyLoop (カウンタが 0 になるまで) 
        
        # --- レンダリング開始 ---
        # PPUCTRL ($2000) - NMI ON, CHR ROM $0000 を使用 (タイル 0-255)
        0xA9, 0x80,  # LDA #%10000000
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        
        # PPUMASK ($2001) - BG ON, Sprite OFF
        0xA9, 0x0E,  # LDA #%00001110 
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)

    #InfiniteLoop (at $C03E):
        0x4C, 0x3E, 0xC0   # JMP InfiniteLoop
    ]
    
    # prg_code は 64 バイト ($40)
    prg_rom = bytearray(prg_code)
    
    # --- データ ($C040 から) ---
    # ネームテーブル (960 バイト)
    prg_rom.extend(nametable)
    
    # アトリビュートテーブル (64 バイト)
    # すべてのタイルがパレット 0 を使うため、すべて 0
    attr_table = bytearray(64) 
    prg_rom.extend(attr_table)
    
    # 16KB にパディング (ベクタ領域 6 バイトを除く)
    padding_size = PRG_ROM_SIZE - len(prg_rom) - 6
    if padding_size < 0:
        print("エラー: PRG ROM が 16KB を超えました。", file=sys.stderr)
        return None
    prg_rom.extend(bytearray(padding_size))

    # --- リセットベクタ (16KB ROM の最後 $FFFA-$FFFF) ---
    prg_rom.extend([
        0x00, 0xC0,  # NMI Vector ($FFFA)
        0x00, 0xC0,  # Reset Vector ($FFFC)
        0x00, 0xC0   # IRQ Vector ($FFFE)
    ])
    
    if len(prg_rom) != PRG_ROM_SIZE:
        print(f"致命的エラー: PRG ROM サイズが {len(prg_rom)} で、{PRG_ROM_SIZE} ではありません。", file=sys.stderr)
        return None
        
    return prg_rom


# --- 5. iNES ヘッダ生成と ROM 書き出し (★ヘッダ修正) ---

def write_nes_rom(output_path, prg_rom, chr_rom):
    """
    iNES ヘッダを生成し、PRG ROM と CHR ROM と結合して .nes ファイルに書き出す。
    """
    print(f"ステップ 5: iNES ヘッダを生成し、'{output_path}' に書き出し中...")
    
    header = bytearray(16)
    header[0:4] = b'NES\x1A'  # "NES" + MS-DOS EOF
    
    # PRG ROM (プログラム) のバンク数 (16KB 単位)
    header[4] = 1  # 1 バンク = 16KB
    
    # CHR ROM (グラフィック) のバンク数 (8KB 単位)
    header[5] = 1  # ★ 1 バンク = 8KB に変更
    
    # Flags 6: マッパー 0, 水平ミラーリング
    header[6] = 0b00000000
    
    # Flags 7: マッパー 0
    header[7] = 0b00000000
    
    # (ヘッダの残りは 0 でOK)
    
    try:
        with open(output_path, 'wb') as f:
            f.write(header)
            f.write(prg_rom)
            f.write(chr_rom)
    except Exception as e:
        print(f"エラー: ROM ファイル '{output_path}' の書き出しに失敗しました。 {e}", file=sys.stderr)
        return False
        
    print("---")
    print(f"✅ 変換完了: {output_path}")
    print(f"   PRG ROM: 16KB (コード+データ)")
    print(f"   CHR ROM: 8KB (グラフィックタイル)")
    print("---")
    return True

# --- メイン実行 (変更なし) ---

def main():
    if len(sys.argv) != 3:
        print(f"使い方: python {os.path.basename(sys.argv[0])} <入力画像.png> <出力.nes>", file=sys.stderr)
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # 1. 画像を読み込み、4 階調ピクセルデータに変換
    pixels = load_and_process_image(input_file)
    if pixels is None:
        sys.exit(1)
        
    # 2. CHR ROM とネームテーブルを生成
    chr_rom, nametable = generate_chr_and_nametable(pixels)
    if chr_rom is None or nametable is None:
        sys.exit(1)
        
    # 3. PRG ROM を生成 (ネームテーブルを埋め込む)
    prg_rom = generate_prg_rom(nametable)
    if prg_rom is None:
        sys.exit(1)
        
    # 4. .nes ファイルとして書き出し
    if not write_nes_rom(output_file, prg_rom, chr_rom):
        sys.exit(1)

if __name__ == "__main__":
    main()
