#!/usr/bin/env python3

"""
rennda_game_builder.py
(c) 2024 (Generated by AI for demonstration)

このスクリプトは、ファミコン (NES) エミュレータで動作する
「連打測定ゲーム」の .nes ROM ファイルを生成します。

依存ライブラリ: なし (Pillow は不要)
"""

import sys
import os

# --- 定数 ---
CHR_ROM_SIZE = 8192    # 8KB (フォント、UI用)
PRG_ROM_SIZE = 16384   # 16KB

# --- 1. CHR ROM (グラフィック) 生成 ---

def generate_font_chr():
    """
    ゲームに必要なフォント (8x8, 2bpp) を CHR ROM として生成する。
    色 0: 黒 (背景), 色 3: 白 (文字)
    """
    print("ステップ 1: CHR ROM (フォント) を生成中...")
    chr_data = bytearray(CHR_ROM_SIZE) # 8KB を 0 で初期化

    # ピクセルデータ (0=黒, 3=白) を 16 バイトの NES タイルデータに変換
    def pixels_to_tile(pixels):
        plane0 = bytearray(8)
        plane1 = bytearray(8)
        for y in range(8):
            byte0 = 0
            byte1 = 0
            for x in range(8):
                color = pixels[y * 8 + x]
                low_bit = (color & 1)
                high_bit = (color >> 1) & 1
                byte0 |= (low_bit << (7 - x))
                byte1 |= (high_bit << (7 - x))
            plane0[y] = byte0
            plane1[y] = byte1
        return plane0 + plane1

    # CHR ROM の指定オフセットにタイルデータを書き込む
    def write_tile(index, pixels):
        offset = index * 16
        if offset + 16 > CHR_ROM_SIZE:
            raise IndexError(f"CHR ROM インデックス {index} が範囲外です。")
        chr_data[offset : offset + 16] = pixels_to_tile(pixels)

    # --- フォントデータの定義 ---
    # (インデックス 0-9 に '0'-'9' を配置)
    font_0 = [
        0,3,3,3,3,3,0,0,
        3,3,0,0,0,3,3,0,
        3,0,3,0,0,0,3,0,
        3,0,0,3,0,0,3,0,
        3,0,0,0,3,0,3,0,
        3,0,3,0,0,3,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_1 = [
        0,0,0,3,3,0,0,0,
        0,0,3,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_2 = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,3,0,
        0,0,0,0,0,3,0,0,
        0,0,0,0,3,0,0,0,
        0,0,3,0,0,0,0,0,
        3,3,3,3,3,3,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_3 = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,3,0,
        0,0,0,3,3,3,0,0,
        0,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_4 = [
        0,0,0,0,3,3,0,0,
        0,0,0,3,0,3,0,0,
        0,0,3,0,0,3,0,0,
        0,3,0,0,0,3,0,0,
        3,3,3,3,3,3,3,0,
        0,0,0,0,0,3,0,0,
        0,0,0,0,0,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_5 = [
        3,3,3,3,3,3,3,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_6 = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_7 = [
        3,3,3,3,3,3,3,0,
        0,0,0,0,0,0,3,0,
        0,0,0,0,0,3,0,0,
        0,0,0,0,3,0,0,0,
        0,0,0,3,0,0,0,0,
        0,0,3,0,0,0,0,0,
        0,0,3,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_8 = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_9 = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,3,0,
        0,0,0,0,0,0,3,0,
        0,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]

    write_tile(0, font_0)
    write_tile(1, font_1)
    write_tile(2, font_2)
    write_tile(3, font_3)
    write_tile(4, font_4)
    write_tile(5, font_5)
    write_tile(6, font_6)
    write_tile(7, font_7)
    write_tile(8, font_8)
    write_tile(9, font_9)

    # (インデックス 10 は空白タイル = 0)

    # (インデックス 11- はアルファベット)
    font_A = [
        0,0,3,3,3,0,0,0,
        0,3,0,0,0,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,3,3,3,3,3,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_C = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_E = [
        3,3,3,3,3,3,3,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,3,3,3,3,3,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,3,3,3,3,3,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_I = [
        0,3,3,3,3,3,3,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,3,3,3,3,3,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_M = [
        3,0,0,0,0,0,3,0,
        3,3,0,0,0,3,3,0,
        3,0,3,0,3,0,3,0,
        3,0,0,3,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_N = [
        3,0,0,0,0,0,3,0,
        3,3,0,0,0,0,3,0,
        3,0,3,0,0,0,3,0,
        3,0,0,3,0,0,3,0,
        3,0,0,0,3,0,3,0,
        3,0,0,0,0,3,3,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_O = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_P = [
        3,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,3,3,3,3,3,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        3,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_R = [
        3,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,3,3,3,3,3,0,0,
        3,0,0,0,3,0,0,0,
        3,0,0,0,0,3,0,0,
        3,0,0,0,0,0,3,0,
        0,0,0,0,0,0,0,0,
    ]
    font_S = [
        0,3,3,3,3,3,0,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,0,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_T = [
        3,3,3,3,3,3,3,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_U = [
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        3,0,0,0,0,0,3,0,
        0,3,3,3,3,3,0,0,
        0,0,0,0,0,0,0,0,
    ]
    
    font_colon = [
        0,0,0,0,0,0,0,0,
        0,0,3,3,0,0,0,0,
        0,0,3,3,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,3,3,0,0,0,0,
        0,0,3,3,0,0,0,0,
        0,0,0,0,0,0,0,0,
    ]
    font_exclam = [
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,3,3,0,0,0,
        0,0,0,0,0,0,0,0,
    ]
    
    # マッピング (タイルインデックス)
    # 0-9: '0'-'9'
    # 10: ' ' (空白)
    # 11: 'A'
    # 12: 'C'
    # 13: 'E'
    # 14: 'I'
    # 15: 'M'
    # 16: 'N'
    # 17: 'O'
    # 18: 'P'
    # 19: 'R'
    # 20: 'S'
    # 21: 'T'
    # 22: 'U'
    # 23: ':'
    # 24: '!'
    
    write_tile(11, font_A)
    write_tile(12, font_C)
    write_tile(13, font_E)
    write_tile(14, font_I)
    write_tile(15, font_M)
    write_tile(16, font_N)
    write_tile(17, font_O)
    write_tile(18, font_P)
    write_tile(19, font_R)
    write_tile(20, font_S)
    write_tile(21, font_T)
    write_tile(22, font_U)
    write_tile(23, font_colon)
    write_tile(24, font_exclam)
    
    # (インデックス 10 と 25+ は 0 のまま = 空白タイル)

    return chr_data

# --- 2. PRG ROM (プログラム) 生成 ---

def generate_prg_rom():
    """
    ゲームロジックの 6502 マシン語 (16KB) を生成する。
    """
    print("ステップ 2: PRG ROM (ゲームロジック) を生成中...")
    
    prg_rom = bytearray(PRG_ROM_SIZE) # 16KB を 0 で初期化

    # --- 6502 マシン語 (バイト配列) ---
    # アセンブリコードを Python のバイト配列 (16進数) として埋め込む
    
    # --- PRG ROM データ (テキストなど) ---
    # $C000 からコードが開始し、データは $E000 付近に配置する
    
    # 0 = タイル 0 ('0')
    # 10 = ' ' (空白)
    # 11 = 'A'
    # 12 = 'C' ...
    
    # "PRESS A TO START" (16文字)
    # P(18), R(19), E(13), S(20), S(20),  (10), A(11),  (10), T(21), O(17),  (10), S(20), T(21), A(11), R(19), T(21)
    text_title = [
        18, 19, 13, 20, 20, 10, 11, 10, 21, 17, 10, 20, 21, 11, 19, 21
    ]
    # "COUNT:" (6文字)
    # C(12), O(17), U(22), N(16), T(21), :(23)
    text_count = [
        12, 17, 22, 16, 21, 23
    ]
    # "TIME:" (5文字)
    # T(21), I(14), M(15), E(13), :(23)
    text_time = [
        21, 14, 15, 13, 23
    ]
    # "TIME UP!!" (9文字)
    # T(21), I(14), M(15), E(13),  (10), U(22), P(18), !(24), !(24)
    text_timeup = [
        21, 14, 15, 13, 10, 22, 18, 24, 24
    ]

    # データを $E000 から配置
    data_offset = 0xE000 - 0xC000 # 0x2000
    
    prg_rom[data_offset : data_offset + len(text_title)] = bytearray(text_title)
    prg_rom[data_offset + 0x20 : data_offset + 0x20 + len(text_count)] = bytearray(text_count)
    prg_rom[data_offset + 0x40 : data_offset + 0x40 + len(text_time)] = bytearray(text_time)
    prg_rom[data_offset + 0x60 : data_offset + 0x60 + len(text_timeup)] = bytearray(text_timeup)
    
    # --- 6502 コード (アセンブリ) ---
    # $C000 から配置
    
    # Zero Page 変数 (アドレス)
    # $00 = GameState (0:Title, 1:Countdown, 2:Game, 3:Result)
    # $01 = FrameCounter (60fps)
    # $02 = Timer (Seconds, 10 -> 0)
    # $03 = RenndaCount_L (連打カウント Low)
    # $04 = RenndaCount_H (連打カウント High)
    # $05 = Controller_Raw (生データ)
    # $06 = Controller_Trg (トリガー, 押した瞬間)
    # $07 = Controller_Old (1フレーム前)
    # $08 = TempA
    # $09 = TempX
    # $0A = TempY
    # $0B = TempPtr_L
    # $0C = TempPtr_H
    # $0D = Digit (10進数変換用)
    
    code = [
        # --- Reset Vector ($FFFC) -> $C000 ---
        # $C000: Reset Handler
        0x78,        # SEI (割り込み禁止)
        0xD8,        # CLD (デシマルモード解除)
        0xA2, 0xFF,  # LDX #$FF (スタックポインタ初期化)
        0x9A,        # TXS
        
        # PPU/APU 初期化
        0xA9, 0x00,  # LDA #$00
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL - NMI OFF)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK - RENDER OFF)
        0x8D, 0x10, 0x40,  # STA $4010 (DMC)
        0x8D, 0x15, 0x40,  # STA $4015 (APU)
        
        # VBlank 待ち (x2)
        0xAD, 0x02, 0x20,  # BIT $2002
        0x10, 0xFB,        # BPL (VBlankWait1)
        0xAD, 0x02, 0x20,  # BIT $2002
        0x10, 0xFB,        # BPL (VBlankWait2)

        # Zero Page 初期化
        0xA2, 0x00,  # LDX #$00
        0xA9, 0x00,  # LDA #$00
    #ClearZP:
        0x95, 0x00,  # STA $00,X
        0xE8,        # INX
        0xE0, 0x10,  # CPX #$10 (最初の 16 バイトをクリア)
        0xD0, 0xF9,        # BNE ClearZP
        
        # VRAM クリア ($2000-$23FF)
        0xA9, 0x20,  # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x10,  # LDA #$10 (空白タイルのインデックス 10)
        0xA2, 0x04,  # LDX #$04 (4 ページ * 256 バイト = 1024 バイト)
    #ClearVRAM_Page:
        0xA0, 0x00,  # LDY #$00
    #ClearVRAM_Loop:
        0x8D, 0x07, 0x20,  # STA $2007
        0xC8,        # INY
        0xD0, 0xFB,  # BNE ClearVRAM_Loop
        0xCA,        # DEX
        0xD0, 0xF7,  # BNE ClearVRAM_Page
        
        # パレットのロード ($3F00-$3F03)
        0xAD, 0x02, 0x20,  # BIT $2002
        0xA9, 0x3F,  # LDA #$3F (PPU アドレス $3F00)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        
        0xA9, 0x0F,  # LDA #$0F (黒 - 背景色)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x00,  # LDA #$00 (暗灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x10,  # LDA #$10 (明灰)
        0x8D, 0x07, 0x20,  # STA $2007
        0xA9, 0x30,  # LDA #$30 (白)
        0x8D, 0x07, 0x20,  # STA $2007
        
        # アトリビュートテーブル ($23C0) をパレット 0 で埋める
        0xA9, 0x23,  # LDA #$23 (PPU アドレス $23C0)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xC0,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,  # LDA #$00 (パレット 0)
        0xA0, 0x40,  # LDY #$40 (64 バイト)
    #ClearAttr_Loop:
        0x8D, 0x07, 0x20,  # STA $2007
        0x88,        # DEY
        0xD0, 0xFB,  # BNE ClearAttr_Loop
        
        # ゲームステートを 0 (Title) に設定
        # (Zero Page は 0 で初期化済み)
        
        # NMI 有効化、BG ON, Sprite OFF
        0xA9, 0x80,  # LDA #%10000000 (NMI ON, BG $0000)
        0x8D, 0x00, 0x20,  # STA $2000 (PPUCTRL)
        0xA9, 0x0E,  # LDA #%00001110 (BG ON)
        0x8D, 0x01, 0x20,  # STA $2001 (PPUMASK)
        
        0x58,        # CLI (割り込み許可)
        
    #InfiniteLoop:
        0x4C, 0x93, 0xC0,  # JMP InfiniteLoop (自分自身にジャンプ $C093)
        
        # --- NMI Vector ($FFFA) -> $C100 ---
        # $C100: NMI Handler (VBlank)
        0x48,        # PHA (レジスタ退避)
        0x8A,        # TXA
        0x48,        # PHA
        0x98,        # TYA
        0x48,        # PHA
        
        # コントローラ読み取り
        0x20, 0x00, 0xC2,  # JSR ReadController ($C200)
        
        # ZP($06, $07) を使ってトリガー (押した瞬間) を計算
        0xA5, 0x05,  # LDA Controller_Raw
        0x49, 0xFF,  # EOR #$FF (ビット反転)
        0x25, 0x07,  # AND Controller_Old
        0x85, 0x06,  # STA Controller_Trg
        0xA5, 0x05,  # LDA Controller_Raw
        0x85, 0x07,  # STA Controller_Old
        
        # --- ゲームロジックメイン ---
        0xA5, 0x00,  # LDA GameState
        0xC9, 0x00,  # CMP #$00 (Title)
        0xF0, 0x10,  # BEQ StateTitle
        0xC9, 0x01,  # CMP #$01 (Countdown)
        0xF0, 0x20,  # BEQ StateCountdown
        0xC9, 0x02,  # CMP #$02 (Game)
        0xF0, 0x40,  # BEQ StateGame
        0xC9, 0x03,  # CMP #$03 (Result)
        0xF0, 0x6A,  # BEQ StateResult
        0x4C, 0xEF, 0xC1,  # JMP NMI_End (ありえない)
        
    #StateTitle: ($C129)
        # "PRESS A TO START" 描画
        0x20, 0x00, 0xC3,  # JSR DrawTextTitle ($C300)
        
        # A ボタン (Bit 7) が押されたか？
        0xA5, 0x06,  # LDA Controller_Trg
        0x29, 0x80,  # AND #%10000000
        0xF0, 0x0E,  # BEQ Title_End
        
        # A が押された -> Countdown へ移行
        0xA9, 0x01,  # LDA #$01 (State Countdown)
        0x85, 0x00,  # STA GameState
        0x20, 0x80, 0xC2,  # JSR ClearVRAM_BG
        0xA9, 0x04,  # LDA #$04 (4 秒, 3, 2, 1, 0)
        0x85, 0x02,  # STA Timer (Seconds)
        0xA9, 0x00,  # LDA #$00
        0x85, 0x01,  # STA FrameCounter
    #Title_End:
        0x4C, 0xEF, 0xC1,  # JMP NMI_End
        
    #StateCountdown: ($C14B)
        0xE6, 0x01,  # INC FrameCounter
        0xA5, 0x01,  # LDA FrameCounter
        0xC9, 0x3C,  # CMP #60 (60 フレーム = 1秒)
        0x90, 0x14,  # BCC Countdown_End
        
        # 1秒経過
        0xA9, 0x00,  # LDA #$00
        0x85, 0x01,  # STA FrameCounter
        0xC6, 0x02,  # DEC Timer
        0xA5, 0x02,  # LDA Timer
        0xF0, 0x03,  # BEQ StartGame (Timer が 0 になったら)
        
        # カウントダウン描画 (Timer-1 を描画)
        0x38,        # SEC
        0xE9, 0x01,  # SBC #$01 ('3', '2', '1')
        0x20, 0x40, 0xC3,  # JSR DrawSingleDigit ($C340)
        0x4C, 0xEF, 0xC1,  # JMP NMI_End

    #StartGame:
        0xA9, 0x02,  # LDA #$02 (State Game)
        0x85, 0x00,  # STA GameState
        0x20, 0x80, 0xC2,  # JSR ClearVRAM_BG
        0xA9, 0x0A,  # LDA #$0A (10 秒)
        0x85, 0x02,  # STA Timer
        
    #Countdown_End:
        0x4C, 0xEF, 0xC1,  # JMP NMI_End
        
    #StateGame: ($C18D)
        # "COUNT:" 描画
        0x20, 0x20, 0xC3,  # JSR DrawTextCount
        # "TIME:" 描画
        0x20, 0x30, 0xC3,  # JSR DrawTextTime
        
        # カウント表示
        0xA5, 0x04,  # LDA RenndaCount_H
        0x85, 0x09,  # STA TempX
        0xA5, 0x03,  # LDA RenndaCount_L
        0x85, 0x08,  # STA TempA
        0x20, 0xA0, 0xC3,  # JSR DrawNumber (3桁)
        
        # 残り時間表示
        0xA9, 0x00,  # LDA #$00
        0x85, 0x09,  # STA TempX
        0xA5, 0x02,  # LDA Timer
        0x85, 0x08,  # STA TempA
        0x20, 0xF0, 0xC3,  # JSR DrawNumber (2桁)
        
        # A ボタン (Bit 7) が押されたか？
        0xA5, 0x06,  # LDA Controller_Trg
        0x29, 0x80,  # AND #%10000000
        0xF0, 0x06,  # BEQ Game_NoRennda
        
        # 連打カウントアップ
        0xE6, 0x03,  # INC RenndaCount_L
        0xD0, 0x02,  # BNE Game_NoRennda
        0xE6, 0x04,  # INC RenndaCount_H
        
    #Game_NoRennda:
        # 1秒タイマー処理
        0xE6, 0x01,  # INC FrameCounter
        0xA5, 0x01,  # LDA FrameCounter
        0xC9, 0x3C,  # CMP #60
        0x90, 0x0B,  # BCC Game_End
        
        # 1秒経過
        0xA9, 0x00,  # LDA #$00
        0x85, 0x01,  # STA FrameCounter
        0xC6, 0x02,  # DEC Timer
        0xA5, 0x02,  # LDA Timer
        0xF0, 0x03,  # BEQ GoToResult
    #Game_End:
        0x4C, 0xEF, 0xC1,  # JMP NMI_End
        
    #GoToResult:
        0xA9, 0x03,  # LDA #$03 (State Result)
        0x85, 0x00,  # STA GameState
        0x20, 0x80, 0xC2,  # JSR ClearVRAM_BG
        0x4C, 0xEF, 0xC1,  # JMP NMI_End
        
    #StateResult: ($C1F3)
        # "TIME UP!!" 描画
        0x20, 0x60, 0xC3,  # JSR DrawTextTimeUp
        # "COUNT:" 描画
        0x20, 0x20, 0xC3,  # JSR DrawTextCount
        # カウント表示
        0xA5, 0x04,  # LDA RenndaCount_H
        0x85, 0x09,  # STA TempX
        0xA5, 0x03,  # LDA RenndaCount_L
        0x85, 0x08,  # STA TempA
        0x20, 0xA0, 0xC3,  # JSR DrawNumber (3桁)
        
        # A ボタン (Bit 7) が押されたか？
        0xA5, 0x06,  # LDA Controller_Trg
        0x29, 0x80,  # AND #%10000000
        0xF0, 0x0D,  # BEQ Result_End
        
        # A が押された -> Title へ移行
        0xA9, 0x00,  # LDA #$00 (State Title)
        0x85, 0x00,  # STA GameState
        0x20, 0x80, 0xC2,  # JSR ClearVRAM_BG
        # カウントリセット
        0x85, 0x03,  # STA RenndaCount_L
        0x85, 0x04,  # STA RenndaCount_H
        
    #Result_End:
        0x4C, 0xEF, 0xC1,  # JMP NMI_End

    #NMI_End: ($C1EF)
        0x68,        # PLA (レジスタ復帰)
        0xA8,        # TAY
        0x68,        # PLA
        0xAA,        # TAX
        0x68,        # PLA
        0x40,        # RTI
        
        # --- サブルーチン ---
        
        # $C200: ReadController
        0xA9, 0x01,  # LDA #$01
        0x8D, 0x16, 0x40,  # STA $4016 (ラッチ)
        0xA9, 0x00,  # LDA #$00
        0x8D, 0x16, 0x40,  # STA $4016
        
        0xA2, 0x08,  # LDX #$08 (8回ループ)
        0xA9, 0x00,  # LDA #$00
        0x85, 0x05,  # STA Controller_Raw
    #ReadLoop:
        0xAD, 0x16, 0x40,  # LDA $4016
        0x29, 0x01,  # AND #%00000001
        0x0A,        # ASL A (キャリーへ)
        0x26, 0x05,  # ROL Controller_Raw (ZPに貯める)
        0xCA,        # DEX
        0xD0, 0xF7,  # BNE ReadLoop
        0x60,        # RTS
        
        # $C280: ClearVRAM_BG (VRAM $2000-$23BF を 10 で埋める)
        0xA9, 0x20,  # LDA #$20 (PPU アドレス $2000)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x00,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x10,  # LDA #$10 (空白タイルのインデックス 10)
        0xA2, 0x03,  # LDX #$03 (3 ページ * 256 バイト)
        0xA0, 0xE0,  # LDY #$E0 (224 バイト) -> $03E0 = 992
    #ClearBG_Loop:
        0x8D, 0x07, 0x20,  # STA $2007
        0x88,        # DEY
        0xD0, 0xFB,  # BNE ClearBG_Loop
        0xCA,        # DEX
        0xD0, 0xF7,  # BNE ClearBG_Loop (これはおかしい)
        # 960 バイトのクリア (3 * 256 + 192)
        # $C294:
        0xA2, 0x03,  # LDX #$03 (3 ページ)
    #ClearBG_Page:
        0xA0, 0x00,  # LDY #$00
    #ClearBG_Byte:
        0x8D, 0x07, 0x20,  # STA $2007
        0xC8,        # INY
        0xD0, 0xFB,  # BNE ClearBG_Byte
        0xCA,        # DEX
        0xD0, 0xF7,  # BNE ClearBG_Page
    # $C29F: (残り 192 バイト)
        0xA0, 0xC0,  # LDY #$C0
    #ClearBG_Rest:
        0x8D, 0x07, 0x20,  # STA $2007
        0x88,        # DEY
        0xD0, 0xFB,  # BNE ClearBG_Rest
        0x60,        # RTS
        
        # $C300: DrawTextTitle ("PRESS A TO START" at $2188)
        0xA9, 0x21,  # LDA #$21 (PPU アドレス $2188)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x88,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xE0,  # LDA #$E0 (データポインタ Low)
        0x85, 0x0B,  # STA TempPtr_L
        0xA9, 0xBF,  # LDA #$BF (データポインタ High - 1) -> $E000
        0x85, 0x0C,  # STA TempPtr_H
        0xA0, 0x10,  # LDY #$10 (16 文字)
        0x20, 0x00, 0xC4,  # JSR DrawTextLoop ($C400)
        0x60,        # RTS
        
        # $C320: DrawTextCount ("COUNT:" at $214A)
        0xA9, 0x21,  # LDA #$21 (PPU アドレス $214A)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x4A,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xE0,  # LDA #$E0 (データポインタ Low + 0x20)
        0x85, 0x0B,  # STA TempPtr_L
        0xA9, 0xBF,  # LDA #$BF
        0x85, 0x0C,  # STA TempPtr_H
        0xA0, 0x06,  # LDY #$06 (6 文字)
        0x20, 0x00, 0xC4,  # JSR DrawTextLoop ($C400)
        0x60,        # RTS

        # $C330: DrawTextTime ("TIME:" at $20C8)
        0xA9, 0x20,  # LDA #$20 (PPU アドレス $20C8)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xC8,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xE0,  # LDA #$E0 (データポインタ Low + 0x40)
        0x85, 0x0B,  # STA TempPtr_L
        0xA9, 0xBF,  # LDA #$BF
        0x85, 0x0C,  # STA TempPtr_H
        0xA0, 0x05,  # LDY #$05 (5 文字)
        0x20, 0x00, 0xC4,  # JSR DrawTextLoop ($C400)
        0x60,        # RTS
        
        # $C340: DrawSingleDigit (A レジスタの数字を $21D0 に描画)
        0x8D, 0x07, 0x20,  # STA $2007 (これはダメ、アドレス設定が必要)
        0xA9, 0x21,  # LDA #$21 (PPU アドレス $21D0)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xD0,
        0x8D, 0x06, 0x20,  # STA $2006
        0x85, 0x08,  # STA TempA (A を保存)
        0xA5, 0x08,  # LDA TempA
        0x8D, 0x07, 0x20,  # STA $2007 (A の値をタイルインデックスとして描画)
        0x60,        # RTS
        
        # $C360: DrawTextTimeUp ("TIME UP!!" at $218B)
        0xA9, 0x21,  # LDA #$21 (PPU アドレス $218B)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x8B,
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xE0,  # LDA #$E0 (データポインタ Low + 0x60)
        0x85, 0x0B,  # STA TempPtr_L
        0xA9, 0xBF,  # LDA #$BF
        0x85, 0x0C,  # STA TempPtr_H
        0xA0, 0x09,  # LDY #$09 (9 文字)
        0x20, 0x00, 0xC4,  # JSR DrawTextLoop ($C400)
        0x60,        # RTS
        
        # $C3A0: DrawNumber (TempA/TempX の 16bit 値を 3桁で $2151 に描画)
        # $C3F0: DrawNumber (TempA/TempX の 16bit 値を 2桁で $20CE に描画)
        
        # $C3A0: DrawNumber (3桁 @ $2151)
        0xA9, 0x21,  # LDA #$21 (PPU アドレス $2151)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0x51,
        0x8D, 0x06, 0x20,  # STA $2006
        
        # 100 の位
        0xA9, 0x00,  # LDA #$00
        0x85, 0x0D,  # STA Digit
    #Div100_Loop:
        0x38,        # SEC
        0xA5, 0x08,  # LDA TempA
        0xE9, 0x64,  # SBC #100
        0x85, 0x08,  # STA TempA
        0xA5, 0x09,  # LDA TempX
        0xE9, 0x00,  # SBC #0
        0x85, 0x09,  # STA TempX
        0x90, 0x02,  # BCC Div100_Done
        0xE6, 0x0D,  # INC Digit
        0x4C, 0xAC, 0xC3,  # JMP Div100_Loop
    #Div100_Done:
        0x18,        # CLC
        0xA5, 0x08,  # LDA TempA
        0x69, 0x64,  # ADC #100
        0x85, 0x08,  # STA TempA
        0xA5, 0x09,  # LDA TempX
        0x69, 0x00,  # ADC #0
        0x85, 0x09,  # STA TempX
        
        0xA5, 0x0D,  # LDA Digit
        0x8D, 0x07, 0x20,  # STA $2007 (100の位描画)

        # 10 の位
        0xA9, 0x00,  # LDA #$00
        0x85, 0x0D,  # STA Digit
    #Div10_Loop:
        0x38,        # SEC
        0xA5, 0x08,  # LDA TempA
        0xE9, 0x0A,  # SBC #10
        0x85, 0x08,  # STA TempA
        0x90, 0x02,  # BCC Div10_Done
        0xE6, 0x0D,  # INC Digit
        0x4C, 0xC9, 0xC3,  # JMP Div10_Loop
    #Div10_Done:
        0x18,        # CLC
        0xA5, 0x08,  # LDA TempA
        0x69, 0x0A,  # ADC #10
        0x85, 0x08,  # STA TempA
        
        0xA5, 0x0D,  # LDA Digit
        0x8D, 0x07, 0x20,  # STA $2007 (10の位描画)
        
        # 1 の位
        0xA5, 0x08,  # LDA TempA (残り)
        0x8D, 0x07, 0x20,  # STA $2007 (1の位描画)
        0x60,        # RTS

        # $C3F0: DrawNumber (2桁 @ $20CE)
        0xA9, 0x20,  # LDA #$20 (PPU アドレス $20CE)
        0x8D, 0x06, 0x20,  # STA $2006
        0xA9, 0xCE,
        0x8D, 0x06, 0x20,  # STA $2006

        # 10 の位 (100の位はスキップ)
        0xA9, 0x00,  # LDA #$00
        0x85, 0x0D,  # STA Digit
    #Div10_Loop_B:
        0x38,        # SEC
        0xA5, 0x08,  # LDA TempA
        0xE9, 0x0A,  # SBC #10
        0x85, 0x08,  # STA TempA
        0x90, 0x02,  # BCC Div10_Done_B
        0xE6, 0x0D,  # INC Digit
        0x4C, 0xF9, 0xC3,  # JMP Div10_Loop_B
    #Div10_Done_B:
        0x18,        # CLC
        0xA5, 0x08,  # LDA TempA
        0x69, 0x0A,  # ADC #10
        0x85, 0x08,  # STA TempA
        
        0xA5, 0x0D,  # LDA Digit
        0x8D, 0x07, 0x20,  # STA $2007 (10の位描画)
        
        # 1 の位
        0xA5, 0x08,  # LDA TempA (残り)
        0x8D, 0x07, 0x20,  # STA $2007 (1の位描画)
        0x60,        # RTS
        
        # $C400: DrawTextLoop (共通テキスト描画)
        # Y=文字数, TempPtr=データアドレス
    #DrawTextLoop:
        0xB1, 0x0B,  # LDA (TempPtr_L),Y
        0x8D, 0x07, 0x20,  # STA $2007
        0x88,        # DEY
        0x10, 0xFA,  # BPL DrawTextLoop
        0x60,        # RTS
        
        # (ここまでで $C408)
    ]
    
    # マシン語コードを PRG ROM の $C000 (オフセット 0) に書き込む
    prg_rom[0x0000 : 0x0000 + len(code)] = bytearray(code)
    
    # --- ベクタ (PRG ROM の最後) ---
    # $FFFA-$FFFB: NMI Vector -> $C100
    prg_rom[0x3FFA] = 0x00
    prg_rom[0x3FFB] = 0xC1
    # $FFFC-$FFFD: Reset Vector -> $C000
    prg_rom[0x3FFC] = 0x00
    prg_rom[0x3FFD] = 0xC0
    # $FFFE-$FFFF: IRQ Vector -> $C000 (使わない)
    prg_rom[0x3FFE] = 0x00
    prg_rom[0x3FFF] = 0xC0
    
    return prg_rom

# --- 3. iNES ヘッダ生成と ROM 書き出し ---

def write_nes_rom(output_path, prg_rom, chr_rom):
    """
    iNES ヘッダを生成し、PRG ROM と CHR ROM と結合して .nes ファイルに書き出す。
    """
    print(f"ステップ 3: iNES ヘッダを生成し、'{output_path}' に書き出し中...")
    
    header = bytearray(16)
    header[0:4] = b'NES\x1A'  # "NES" + MS-DOS EOF
    
    # PRG ROM (プログラム) のバンク数 (16KB 単位)
    header[4] = 1  # 1 バンク = 16KB
    
    # CHR ROM (グラフィック) のバンク数 (8KB 単位)
    header[5] = 1  # 1 バンク = 8KB
    
    # Flags 6: マッパー 0, 水平ミラーリング
    header[6] = 0b00000000
    
    # Flags 7: マッパー 0
    header[7] = 0b00000000
    
    try:
        with open(output_path, 'wb') as f:
            f.write(header)
            f.write(prg_rom)
            f.write(chr_rom)
    except Exception as e:
        print(f"エラー: ROM ファイル '{output_path}' の書き出しに失敗しました。 {e}", file=sys.stderr)
        return False
        
    print("---")
    print(f"✅ ビルド完了: {output_path}")
    print(f"   PRG ROM: 16KB (ゲームロジック)")
    print(f"   CHR ROM: 8KB (フォント)")
    print("---")
    return True

# --- メイン実行 ---

def main():
    if len(sys.argv) != 2:
        print(f"使い方: python {os.path.basename(sys.argv[0])} <出力.nes>", file=sys.stderr)
        sys.exit(1)
        
    output_file = sys.argv[1]
    
    # 1. CHR ROM (フォント) を生成
    chr_rom = generate_font_chr()
    if chr_rom is None:
        sys.exit(1)
        
    # 2. PRG ROM (ゲームロジック) を生成
    prg_rom = generate_prg_rom()
    if prg_rom is None:
        sys.exit(1)
        
    # 3. .nes ファイルとして書き出し
    if not write_nes_rom(output_file, prg_rom, chr_rom):
        sys.exit(1)

if __name__ == "__main__":
    main()
